#!/usr/bin/env python3
"""
Script pour harmoniser pr√©cis√©ment les contraintes hydrauliques entre EPANET et LCPI.
Objectif : √âliminer les diff√©rences de contraintes qui pourraient expliquer les √©carts.
"""

import sys
import json
import subprocess
import os
from pathlib import Path
from typing import Dict, List, Any

def analyze_constraint_definitions():
    """Analyse les d√©finitions de contraintes dans les deux solveurs."""
    
    print("üîç ANALYSE DES D√âFINITIONS DE CONTRAINTES")
    print("=" * 60)
    
    # Fichiers √† analyser pour les contraintes
    constraint_files = [
        "src/lcpi/aep/optimizer/constraints_handler.py",
        "src/lcpi/aep/optimization/genetic_algorithm.py",
        "src/lcpi/aep/optimizer/controllers.py"
    ]
    
    print("\nüìä CONTRAINTES IDENTIFI√âES:")
    
    for file_path in constraint_files:
        if Path(file_path).exists():
            print(f"\nüìÅ {file_path}:")
            
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            # Chercher les contraintes de pression
            if "pression_min" in content or "pressure_min" in content:
                print("   üìè Contraintes de pression: D√©tect√©es")
                
            if "vitesse_max" in content or "velocity_max" in content:
                print("   üèÉ Contraintes de vitesse: D√©tect√©es")
                
            if "vitesse_min" in content or "velocity_min" in content:
                print("   üêå Contraintes de vitesse min: D√©tect√©es")
                
            # Chercher les valeurs par d√©faut
            if "pressure_default_min" in content:
                print("   üí° Valeur par d√©faut pression: D√©finie")
                
            if "velocity_max_default" in content:
                print("   üí° Valeur par d√©faut vitesse max: D√©finie")

def _resolve_input_file() -> Path:
    """R√©sout un fichier INP existant √† utiliser pour les tests."""
    candidates = [
        Path("bismark_inp.inp"),
        Path("examples") / "bismark-Administrator.inp",
        Path("examples") / "bismark-Administrator.inp.backup",
    ]
    for candidate in candidates:
        if candidate.exists():
            return candidate
    return Path("bismark_inp.inp")


def _find_result_json(basename: str) -> Path | None:
    """Trouve le fichier JSON de r√©sultat attendu.

    Essaye √† la racine puis dans le dossier `results/` avec variantes.
    """
    direct = Path(f"{basename}.json")
    if direct.exists():
        return direct
    # Cherche dans results/ exact
    results_dir = Path("results")
    if results_dir.exists():
        candidate = results_dir / f"{basename}.json"
        if candidate.exists():
            return candidate
        # Cherche fichiers qui commencent par basename (ex: basename_timestamp.json)
        matches = list(results_dir.glob(f"{basename}*.json"))
        if matches:
            # Prend le plus r√©cent
            matches.sort(key=lambda p: p.stat().st_mtime, reverse=True)
            return matches[0]
    return None


def _run_cmd(cmd: list[str], label: str) -> tuple[bool, str, str]:
    """Ex√©cute une commande avec timeout et retourne (ok, stdout, stderr)."""
    try:
        env = os.environ.copy()
        env['PYTHONIOENCODING'] = 'utf-8'
        env['PYTHONUTF8'] = '1'
        completed = subprocess.run(
            cmd,
            check=False,
            capture_output=True,
            text=True,
            encoding='utf-8',
            env=env,
            timeout=300,
        )
        ok = completed.returncode == 0
        if not ok:
            print(f"   ‚ùå {label} a retourn√© le code {completed.returncode}")
        return ok, completed.stdout, completed.stderr
    except subprocess.TimeoutExpired as e:
        print(f"   ‚è±Ô∏è Timeout pendant {label} (>{e.timeout}s)")
        return False, e.stdout or "", e.stderr or ""


def test_constraint_harmonization():
    """Teste l'harmonisation des contraintes."""
    
    print("\nüß™ TEST D'HARMONISATION DES CONTRAINTES")
    print("=" * 60)
    
    input_path = _resolve_input_file()
    if not input_path.exists():
        print(f"‚ùå Aucun fichier INP trouv√© parmi les candidats. Essay√©: bismark_inp.inp, examples/bismark-Administrator.inp(.backup)")
        return
    else:
        print(f"   üìÑ Fichier INP utilis√©: {input_path}")
    
    # Configurations de contraintes √† tester
    constraint_configs = [
        {
            "name": "Contraintes Standard",
            "pressure_min": 15.0,
            "velocity_max": 2.0,
            "velocity_min": 0.5
        },
        {
            "name": "Contraintes Strictes",
            "pressure_min": 20.0,
            "velocity_max": 1.5,
            "velocity_min": 0.8
        },
        {
            "name": "Contraintes Souples",
            "pressure_min": 10.0,
            "velocity_max": 3.0,
            "velocity_min": 0.3
        },
        {
            "name": "Contraintes EPANET-like",
            "pressure_min": 18.0,
            "velocity_max": 2.5,
            "velocity_min": 0.6
        }
    ]
    
    results = []
    
    for config in constraint_configs:
        print(f"\nüéØ Test: {config['name']}")
        print(f"   Pression min: {config['pressure_min']} m")
        print(f"   Vitesse max: {config['velocity_max']} m/s")
        print(f"   Vitesse min: {config['velocity_min']} m/s")
        
        # Test avec EPANET
        epanet_output = f"epanet_constraints_{config['pressure_min']}_{config['velocity_max']}"
        epanet_cmd = [
            sys.executable, "-m", "lcpi.aep.cli", "network-optimize-unified",
            str(input_path),
            "--method", "genetic",
            "--generations", "15",
            "--population", "25",
            "--solver", "epanet",
            "--pression-min", str(config['pressure_min']),
            "--vitesse-max", str(config['velocity_max']),
            "--vitesse-min", str(config['velocity_min']),
            "--show-stats",
            "--output", epanet_output,
            "--no-log"
        ]
        
        # Test avec LCPI
        lcpi_output = f"lcpi_constraints_{config['pressure_min']}_{config['velocity_max']}"
        lcpi_cmd = [
            sys.executable, "-m", "lcpi.aep.cli", "network-optimize-unified",
            str(input_path),
            "--method", "genetic",
            "--generations", "15",
            "--population", "25",
            "--solver", "lcpi",
            "--pression-min", str(config['pressure_min']),
            "--vitesse-max", str(config['velocity_max']),
            "--vitesse-min", str(config['velocity_min']),
            "--show-stats",
            "--output", lcpi_output,
            "--no-log"
        ]
        
        try:
            print("   üîÑ Ex√©cution EPANET...")
            ok1, out1, err1 = _run_cmd(epanet_cmd, "EPANET")
            if not ok1:
                print("   ‚îú‚îÄ stdout (EPANET):\n" + (out1[-2000:] if out1 else ""))
                print("   ‚îî‚îÄ stderr (EPANET):\n" + (err1[-2000:] if err1 else ""))
            
            print("   üîÑ Ex√©cution LCPI...")
            ok2, out2, err2 = _run_cmd(lcpi_cmd, "LCPI")
            if not ok2:
                print("   ‚îú‚îÄ stdout (LCPI):\n" + (out2[-2000:] if out2 else ""))
                print("   ‚îî‚îÄ stderr (LCPI):\n" + (err2[-2000:] if err2 else ""))
            
            # Analyser les r√©sultats
            epanet_file = _find_result_json(epanet_output)
            lcpi_file = _find_result_json(lcpi_output)
            
            if epanet_file and lcpi_file and epanet_file.exists() and lcpi_file.exists():
                # Charger les r√©sultats EPANET
                with open(epanet_file, 'r', encoding='utf-8') as f:
                    epanet_data = json.load(f)
                
                # Charger les r√©sultats LCPI
                with open(lcpi_file, 'r', encoding='utf-8') as f:
                    lcpi_data = json.load(f)
                
                epanet_props = epanet_data.get("proposals", [])
                lcpi_props = lcpi_data.get("proposals", [])
                
                if epanet_props and lcpi_props:
                    epanet_best = epanet_props[0]
                    lcpi_best = lcpi_props[0]
                    
                    epanet_cost = epanet_best.get("CAPEX", 0)
                    lcpi_cost = lcpi_best.get("CAPEX", 0)
                    epanet_feasible = epanet_best.get("constraints_ok", False)
                    lcpi_feasible = lcpi_best.get("constraints_ok", False)
                    
                    print(f"   üí∞ EPANET: {epanet_cost:,.0f} FCFA ({'‚úÖ' if epanet_feasible else '‚ùå'})")
                    print(f"   üí∞ LCPI  : {lcpi_cost:,.0f} FCFA ({'‚úÖ' if lcpi_feasible else '‚ùå'})")
                    
                    if epanet_cost > 0:
                        delta = lcpi_cost - epanet_cost
                        delta_percent = (delta / epanet_cost) * 100
                        print(f"   üìä Diff√©rence: {delta:+,.0f} FCFA ({delta_percent:+.1f}%)")
                    
                    results.append({
                        "config": config,
                        "epanet": {"cost": epanet_cost, "feasible": epanet_feasible},
                        "lcpi": {"cost": lcpi_cost, "feasible": lcpi_feasible}
                    })
                else:
                    print("   ‚ùå Aucune proposition trouv√©e dans les JSON")
            else:
                print("   ‚ùå Fichiers de r√©sultats manquants")
                print(f"      - Cherch√©: {epanet_output}.json et {lcpi_output}.json")
                print(f"      - Essai dossiers: ./ et ./results/")
                
        except subprocess.CalledProcessError as e:
            print(f"   ‚ùå Erreur d'ex√©cution: {e}")
        except Exception as e:  # S√©curit√© pour voir les erreurs inattendues
            print(f"   ‚ùå Exception inattendue: {e}")
    
    return results

def analyze_constraint_impact(results: List[Dict[str, Any]]):
    """Analyse l'impact des contraintes sur les r√©sultats."""
    
    print("\nüìä ANALYSE DE L'IMPACT DES CONTRAINTES")
    print("=" * 60)
    
    if not results:
        print("‚ùå Aucun r√©sultat √† analyser")
        return
    
    print("\nüìà COMPARAISON PAR CONFIGURATION:")
    
    for i, result in enumerate(results):
        config = result["config"]
        epanet = result["epanet"]
        lcpi = result["lcpi"]
        
        print(f"\n{i+1}. {config['name']}:")
        print(f"   üìè Pression min: {config['pressure_min']} m")
        print(f"   üèÉ Vitesse max: {config['velocity_max']} m/s")
        print(f"   üí∞ EPANET: {epanet['cost']:,.0f} FCFA ({'‚úÖ' if epanet['feasible'] else '‚ùå'})")
        print(f"   üí∞ LCPI  : {lcpi['cost']:,.0f} FCFA ({'‚úÖ' if lcpi['feasible'] else '‚ùå'})")
        
        if epanet['cost'] > 0:
            delta = lcpi['cost'] - epanet['cost']
            delta_percent = (delta / epanet['cost']) * 100
            print(f"   üìä √âcart: {delta:+,.0f} FCFA ({delta_percent:+.1f}%)")
    
    # Analyser les tendances
    print(f"\nüìä TENDANCES GLOBALES:")
    
    feasible_pairs = [r for r in results if r["epanet"]["feasible"] and r["lcpi"]["feasible"]]
    infeasible_pairs = [r for r in results if not r["epanet"]["feasible"] or not r["lcpi"]["feasible"]]
    
    print(f"   Paires faisables: {len(feasible_pairs)}/{len(results)}")
    print(f"   Paires avec infaisabilit√©: {len(infeasible_pairs)}/{len(results)}")
    
    if feasible_pairs:
        avg_delta_feasible = sum(
            (r["lcpi"]["cost"] - r["epanet"]["cost"]) / r["epanet"]["cost"] * 100 
            for r in feasible_pairs if r["epanet"]["cost"] > 0
        ) / len(feasible_pairs)
        print(f"   üìä √âcart moyen (faisable): {avg_delta_feasible:+.1f}%")

def generate_harmonization_recommendations():
    """G√©n√®re des recommandations d'harmonisation."""
    
    print("\nüí° RECOMMANDATIONS D'HARMONISATION")
    print("=" * 60)
    
    recommendations = [
        {
            "category": "Contraintes de Pression",
            "items": [
                "Utiliser la m√™me valeur de pression minimale pour les deux solveurs",
                "V√©rifier que les unit√©s sont coh√©rentes (m vs mCE)",
                "Impl√©menter des contraintes de pression par n≈ìud si n√©cessaire"
            ]
        },
        {
            "category": "Contraintes de Vitesse",
            "items": [
                "Harmoniser les seuils de vitesse maximale et minimale",
                "V√©rifier la coh√©rence des unit√©s (m/s)",
                "Impl√©menter des contraintes de vitesse par conduite"
            ]
        },
        {
            "category": "Application des Contraintes",
            "items": [
                "Utiliser le m√™me mode d'application (soft vs hard)",
                "Harmoniser les poids de p√©nalit√©",
                "Impl√©menter la m√™me logique de tol√©rance"
            ]
        },
        {
            "category": "Validation des R√©sultats",
            "items": [
                "V√©rifier que les contraintes sont bien respect√©es",
                "Comparer les m√©triques hydrauliques d√©taill√©es",
                "Analyser les violations de contraintes"
            ]
        }
    ]
    
    for rec in recommendations:
        print(f"\nüìã {rec['category']}:")
        for item in rec['items']:
            print(f"   ‚Ä¢ {item}")

def main():
    """Fonction principale."""
    
    print("üîß HARMONISATION DES CONTRAINTES HYDRAULIQUES")
    print("=" * 80)
    print("Objectif: √âliminer les diff√©rences de contraintes entre EPANET et LCPI")
    
    # 1. Analyser les d√©finitions actuelles
    analyze_constraint_definitions()
    
    # 2. Tester l'harmonisation
    results = test_constraint_harmonization()
    
    # 3. Analyser l'impact
    analyze_constraint_impact(results)
    
    # 4. G√©n√©rer les recommandations
    generate_harmonization_recommendations()
    
    print("\nüéØ PROCHAINES √âTAPES:")
    print("1. Impl√©menter les recommandations d'harmonisation")
    print("2. Tester avec des contraintes parfaitement align√©es")
    print("3. Valider la coh√©rence des r√©sultats")
    print("4. Documenter les contraintes harmonis√©es")

if __name__ == "__main__":
    main()
