#!/usr/bin/env python3
"""
Script d'harmonisation des contraintes hydrauliques entre EPANET et LCPI.

Ce script v√©rifie et harmonise les seuils de pression, vitesse et autres contraintes
hydrauliques pour assurer une √©valuation coh√©rente des solutions.
"""

import os
import sys
import json
from pathlib import Path
from typing import Dict, Any, List

# Forcer l'encodage UTF-8 pour le terminal
if sys.platform.startswith('win'):
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.detach())
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.detach())
    
    # Forcer l'encodage de la console Windows
    try:
        import subprocess
        subprocess.run(['chcp', '65001'], shell=True, check=True, capture_output=True)
    except:
        pass

# Ajouter le r√©pertoire src au path
ROOT = Path(__file__).resolve().parents[1]
sys.path.insert(0, str(ROOT / "src"))

def get_project_constraints() -> Dict[str, Any]:
    """R√©cup√®re les contraintes du projet depuis la configuration."""
    
    # Contraintes standard du projet AEP
    project_constraints = {
        "pressure": {
            "min_mce": 10.0,      # Pression minimale en mCE
            "max_mce": 100.0,     # Pression maximale en mCE
            "critical_mce": 5.0    # Pression critique (alerte)
        },
        "velocity": {
            "min_ms": 0.3,        # Vitesse minimale en m/s
            "max_ms": 3.0,        # Vitesse maximale en m/s
            "optimal_min_ms": 0.5, # Vitesse optimale minimale
            "optimal_max_ms": 2.5  # Vitesse optimale maximale
        },
        "flow": {
            "min_lps": 0.1,       # D√©bit minimal en L/s
            "max_lps": 1000.0     # D√©bit maximal en L/s
        },
        "quality": {
            "min_contact_time_minutes": 30,  # Temps de contact minimal
            "max_turbidity_ntu": 1.0         # Turbidit√© maximale
        }
    }
    
    print(f"‚úÖ Contraintes du projet AEP:")
    for category, constraints in project_constraints.items():
        print(f"   ‚Ä¢ {category}:")
        for key, value in constraints.items():
            print(f"     - {key}: {value}")
    
    return project_constraints

def get_constraints_handler_config() -> Dict[str, Any]:
    """R√©cup√®re la configuration du gestionnaire de contraintes."""
    try:
        from lcpi.aep.optimizer.constraints_handler import ConstraintManager, ConstraintPenaltyCalculator
        
        # Cr√©er une instance pour tester
        penalty_calculator = ConstraintPenaltyCalculator()
        constraint_manager = ConstraintManager(penalty_calculator)
        
        # Configuration actuelle
        handler_config = {
            "penalty_calculator": {
                "base_penalty_factor": penalty_calculator.base_penalty_factor,
                "velocity_penalty_method": "non_linear",
                "pressure_penalty_method": "non_linear",
                "budget_penalty_method": "exponential"
            },
            "constraint_manager": {
                "available": True,
                "version": "1.0"
            }
        }
        
        print(f"‚úÖ Gestionnaire de contraintes:")
        print(f"   ‚Ä¢ Facteur de p√©nalit√© de base: {handler_config['penalty_calculator']['base_penalty_factor']}")
        print(f"   ‚Ä¢ M√©thode de p√©nalit√© vitesse: {handler_config['penalty_calculator']['velocity_penalty_method']}")
        print(f"   ‚Ä¢ M√©thode de p√©nalit√© pression: {handler_config['penalty_calculator']['pressure_penalty_method']}")
        
        return handler_config
        
    except ImportError as e:
        print(f"‚ö†Ô∏è Impossible d'importer le gestionnaire de contraintes: {e}")
        return {
            "penalty_calculator": {
                "base_penalty_factor": 1000.0,
                "velocity_penalty_method": "unknown",
                "pressure_penalty_method": "unknown"
            },
            "constraint_manager": {
                "available": False,
                "version": "unknown"
            }
        }

def get_epanet_constraints() -> Dict[str, Any]:
    """R√©cup√®re les contraintes EPANET standard."""
    
    # Contraintes EPANET standard (bas√©es sur la documentation)
    epanet_constraints = {
        "pressure": {
            "min_mce": 10.0,      # Pression minimale recommand√©e
            "max_mce": 100.0,     # Pression maximale recommand√©e
            "warning_mce": 15.0    # Seuil d'alerte
        },
        "velocity": {
            "min_ms": 0.3,        # Vitesse minimale pour √©viter la s√©dimentation
            "max_ms": 3.0,        # Vitesse maximale pour √©viter l'√©rosion
            "optimal_ms": [0.5, 2.5]  # Plage optimale
        },
        "flow": {
            "min_lps": 0.1,       # D√©bit minimal mesurable
            "max_lps": 1000.0     # D√©bit maximal typique
        }
    }
    
    print(f"Contraintes EPANET standard:")
    for category, constraints in epanet_constraints.items():
        print(f"   ‚Ä¢ {category}:")
        for key, value in constraints.items():
            print(f"     - {key}: {value}")
    
    return epanet_constraints

def check_constraints_compatibility(project: Dict[str, Any], 
                                  epanet: Dict[str, Any]) -> Dict[str, Any]:
    """V√©rifie la compatibilit√© des contraintes entre le projet et EPANET."""
    
    print(f"\nüîç V√âRIFICATION DE LA COMPATIBILIT√â DES CONTRAINTES")
    print("=" * 60)
    
    compatibility_report = {
        "pressure": {},
        "velocity": {},
        "flow": {},
        "overall_compatibility": True,
        "warnings": [],
        "recommendations": []
    }
    
    # V√©rifier la pression
    p_min_project = project["pressure"]["min_mce"]
    p_min_epanet = epanet["pressure"]["min_mce"]
    
    if abs(p_min_project - p_min_epanet) < 0.1:
        compatibility_report["pressure"]["min"] = "compatible"
    else:
        compatibility_report["pressure"]["min"] = "incompatible"
        compatibility_report["overall_compatibility"] = False
        compatibility_report["warnings"].append(
            f"Pression minimale diff√©rente: Projet ({p_min_project}) vs EPANET ({p_min_epanet})"
        )
    
    # V√©rifier la vitesse
    v_min_project = project["velocity"]["min_ms"]
    v_min_epanet = epanet["velocity"]["min_ms"]
    v_max_project = project["velocity"]["max_ms"]
    v_max_epanet = epanet["velocity"]["max_ms"]
    
    if abs(v_min_project - v_min_epanet) < 0.01:
        compatibility_report["velocity"]["min"] = "compatible"
    else:
        compatibility_report["velocity"]["min"] = "incompatible"
        compatibility_report["overall_compatibility"] = False
        compatibility_report["warnings"].append(
            f"Vitesse minimale diff√©rente: Projet ({v_min_project}) vs EPANET ({v_min_epanet})"
        )
    
    if abs(v_max_project - v_max_epanet) < 0.01:
        compatibility_report["velocity"]["max"] = "compatible"
    else:
        compatibility_report["velocity"]["max"] = "incompatible"
        compatibility_report["overall_compatibility"] = False
        compatibility_report["warnings"].append(
            f"Vitesse maximale diff√©rente: Projet ({v_max_project}) vs EPANET ({v_max_epanet})"
        )
    
    # G√©n√©rer des recommandations
    if compatibility_report["overall_compatibility"]:
        compatibility_report["recommendations"].append(
            "‚úÖ Toutes les contraintes sont compatibles - aucune action n√©cessaire"
        )
                else:
        compatibility_report["recommendations"].append(
            "üîß Harmoniser les contraintes incompatibles pour assurer une √©valuation coh√©rente"
        )
        compatibility_report["recommendations"].append(
            "üìä Utiliser les m√™mes seuils pour les deux solveurs"
        )
    
    return compatibility_report

def create_harmonized_constraints(project: Dict[str, Any], 
                                 epanet: Dict[str, Any],
                                 compatibility: Dict[str, Any]) -> Dict[str, Any]:
    """Cr√©e des contraintes harmonis√©es."""
    
    print(f"\nüîß CR√âATION DES CONTRAINTES HARMONIS√âES")
    print("=" * 60)
    
    # Utiliser les valeurs du projet comme r√©f√©rence principale
    harmonized_constraints = {
        "pressure": {
            "min_mce": project["pressure"]["min_mce"],
            "max_mce": project["pressure"]["max_mce"],
            "critical_mce": project["pressure"]["critical_mce"],
            "warning_mce": epanet["pressure"]["warning_mce"]
        },
        "velocity": {
            "min_ms": project["velocity"]["min_ms"],
            "max_ms": project["velocity"]["max_ms"],
            "optimal_min_ms": project["velocity"]["optimal_min_ms"],
            "optimal_max_ms": project["velocity"]["optimal_max_ms"]
        },
        "flow": {
            "min_lps": project["flow"]["min_lps"],
            "max_lps": project["flow"]["max_lps"]
        },
        "quality": project["quality"],
        "metadata": {
            "source": "harmonized_project_epanet",
            "version": "1.0",
            "compatibility": compatibility["overall_compatibility"]
        }
    }
    
    print(f"‚úÖ Contraintes harmonis√©es cr√©√©es:")
    print(f"   ‚Ä¢ Pression minimale: {harmonized_constraints['pressure']['min_mce']} mCE")
    print(f"   ‚Ä¢ Vitesse minimale: {harmonized_constraints['velocity']['min_ms']} m/s")
    print(f"   ‚Ä¢ Vitesse maximale: {harmonized_constraints['velocity']['max_ms']} m/s")
    print(f"   ‚Ä¢ Compatibilit√©: {'‚úÖ' if compatibility['overall_compatibility'] else '‚ö†Ô∏è'}")
    
    return harmonized_constraints

def save_harmonized_constraints(constraints: Dict[str, Any], 
                               output_path: str = "harmonized_hydraulic_constraints.json") -> bool:
    """Sauvegarde les contraintes harmonis√©es."""
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(constraints, f, indent=2, ensure_ascii=False)
        
        print(f"\nüíæ Contraintes harmonis√©es sauvegard√©es dans: {output_path}")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la sauvegarde: {e}")
        return False

def generate_implementation_guide(constraints: Dict[str, Any], 
                                compatibility: Dict[str, Any]) -> None:
    """G√©n√®re un guide d'impl√©mentation pour l'harmonisation."""
    
    print(f"\nüìã GUIDE D'IMPL√âMENTATION")
    print("=" * 60)
    
    if compatibility["overall_compatibility"]:
        print("‚úÖ Aucune action d'impl√©mentation n√©cessaire - contraintes d√©j√† harmonis√©es")
    else:
        print("üîß Actions d'impl√©mentation requises:")
        
        for warning in compatibility["warnings"]:
            print(f"   ‚Ä¢ {warning}")
        
        print(f"\nüìù √âtapes d'impl√©mentation:")
        print(f"   1. Mettre √† jour constraints_handler.py avec les nouvelles valeurs")
        print(f"   2. V√©rifier que EPANET utilise les m√™mes seuils")
        print(f"   3. Tester la coh√©rence des √©valuations")
        print(f"   4. Valider sur des cas d'usage r√©els")
    
    print(f"\nüí° Bonnes pratiques:")
    print(f"   ‚Ä¢ Utiliser les m√™mes seuils pour tous les solveurs")
    print(f"   ‚Ä¢ Documenter les choix de contraintes")
    print(f"   ‚Ä¢ Tester r√©guli√®rement la coh√©rence")
    print(f"   ‚Ä¢ Maintenir un historique des modifications")

def main():
    """Fonction principale."""
    print("üöÄ HARMONISATION DES CONTRAINTES HYDRAULIQUES")
    print("=" * 60)
    
    try:
        # R√©cup√©rer les contraintes
        project_constraints = get_project_constraints()
        epanet_constraints = get_epanet_constraints()
        handler_config = get_constraints_handler_config()
        
        # V√©rifier la compatibilit√©
        compatibility = check_constraints_compatibility(project_constraints, epanet_constraints)
        
        # Cr√©er les contraintes harmonis√©es
        harmonized_constraints = create_harmonized_constraints(
            project_constraints, epanet_constraints, compatibility
        )
        
        # Sauvegarder
        save_harmonized_constraints(harmonized_constraints)
        
        # G√©n√©rer le guide d'impl√©mentation
        generate_implementation_guide(harmonized_constraints, compatibility)
        
        print(f"\n‚úÖ Harmonisation des contraintes termin√©e avec succ√®s!")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de l'harmonisation: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
