#!/usr/bin/env python3
"""
Test de compatibilit√© entre le format V11 et la commande 'lcpi rapport'
"""

import sys
import json
import tempfile
from pathlib import Path

sys.path.insert(0, 'src')

def test_v11_to_log_format_compatibility():
    """Test la conversion du format V11 vers le format de log LCPI."""
    print("üß™ Test de compatibilit√© Format V11 ‚Üí Format Log LCPI")
    print("=" * 55)
    
    try:
        from lcpi.aep.optimizer.output import OutputFormatter
        from lcpi.aep.optimizer.models import OptimizationResult, Proposal, TankDecision
        from lcpi.lcpi_logging.logger import lcpi_logger
        from datetime import datetime
        
        # 1. Cr√©er un r√©sultat V11
        tank = TankDecision(id="TANK1", H_m=65.0)
        proposal = Proposal(
            name="test_solution",
            is_feasible=True,
            tanks=[tank],
            diameters_mm={"PIPE1": 200, "PIPE2": 150},
            costs={"CAPEX": 150000, "OPEX_annual": 5000, "OPEX_npv": 45000},
            metrics={"min_pressure_m": 12.5, "max_velocity_m_s": 1.8}
        )
        
        result = OptimizationResult(
            proposals=[proposal],
            pareto_front=None,
            metadata={
                "method": "nested_greedy",
                "network_file": "test_network.inp",
                "algorithm": "NestedGreedy",
                "iterations": 25
            }
        )
        
        print("‚úÖ R√©sultat V11 cr√©√© avec succ√®s")
        
        # 2. Convertir en format V11
        formatter = OutputFormatter()
        v11_output = formatter.format_v11(result)
        
        print("‚úÖ Format V11 g√©n√©r√©")
        
        # 3. Cr√©er un adaptateur pour le format de log
        def convert_v11_to_log_format(v11_result: dict) -> dict:
            """Convertit un r√©sultat V11 en format de log compatible avec lcpi rapport."""
            return {
                "id": f"opt_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                "titre_calcul": f"Optimisation AEP - {v11_result['metadata'].get('method', 'unknown')}",
                "timestamp": datetime.now().isoformat(),
                "commande_executee": "lcpi aep optimizer price-optimize",
                "donnees_resultat": v11_result,
                "transparence_mathematique": [
                    f"M√©thode: {v11_result['metadata'].get('method', 'N/A')}",
                    f"R√©seau: {v11_result['metadata'].get('network_file', 'N/A')}",
                    f"Propositions: {len(v11_result['proposals'])}",
                    f"Solutions faisables: {len([p for p in v11_result['proposals'] if p.get('is_feasible', False)])}"
                ],
                "hash_donnees_entree": "test_hash_v11",
                "parametres_entree": {
                    "network_file": v11_result['metadata'].get('network_file'),
                    "method": v11_result['metadata'].get('method'),
                    "iterations": v11_result['metadata'].get('iterations')
                },
                "version_algorithme": "V11",
                "plugin": "aep",
                "command": "optimizer"
            }
        
        # 4. Convertir le format V11 en format de log
        log_format = convert_v11_to_log_format(v11_output)
        
        print("‚úÖ Conversion V11 ‚Üí Log r√©ussie")
        print(f"   Titre: {log_format['titre_calcul']}")
        print(f"   Plugin: {log_format['plugin']}")
        print(f"   Commande: {log_format['command']}")
        
        # 5. V√©rifier que le format est compatible avec le rapport
        required_fields = ['id', 'titre_calcul', 'timestamp', 'commande_executee', 
                          'donnees_resultat', 'transparence_mathematique']
        
        missing_fields = [field for field in required_fields if field not in log_format]
        if missing_fields:
            print(f"‚ùå Champs manquants: {missing_fields}")
            return False
        
        print("‚úÖ Tous les champs requis sont pr√©sents")
        
        # 6. Test de compatibilit√© avec le g√©n√©rateur de rapport
        try:
            from lcpi.reporting.report_generator import ReportGenerator
            
            # Cr√©er un fichier temporaire avec le format de log
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as temp_file:
                json.dump(log_format, temp_file, indent=2, ensure_ascii=False)
                temp_path = Path(temp_file.name)
            
            # Tester la g√©n√©ration de rapport
            template_dir = Path("src/lcpi/reporting/templates")
            if template_dir.exists():
                report_gen = ReportGenerator(template_dir=template_dir)
                
                # Charger le projet metadata par d√©faut
                project_metadata = {"nom_projet": "Test Projet V11"}
                
                # G√©n√©rer le rapport HTML
                html_content = report_gen.generate_html_report([temp_path], project_metadata)
                
                if html_content and len(html_content) > 1000:  # V√©rifier qu'il y a du contenu
                    print("‚úÖ Rapport HTML g√©n√©r√© avec succ√®s")
                    print(f"   Taille: {len(html_content)} caract√®res")
                    
                    # V√©rifier que le contenu V11 est pr√©sent
                    if "Optimisation AEP" in html_content and "nested_greedy" in html_content:
                        print("‚úÖ Contenu V11 correctement int√©gr√© dans le rapport")
                    else:
                        print("‚ö†Ô∏è  Contenu V11 peut-√™tre manquant dans le rapport")
                else:
                    print("‚ùå Rapport HTML vide ou trop petit")
                    return False
            else:
                print("‚ö†Ô∏è  R√©pertoire de templates non trouv√©, test de g√©n√©ration ignor√©")
            
            # Nettoyer le fichier temporaire
            temp_path.unlink()
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la g√©n√©ration de rapport: {e}")
            return False
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test de compatibilit√©: {e}")
        return False

def test_v11_template_vs_existing_template():
    """Compare le template V11 avec le template existant."""
    print("\nüß™ Test de compatibilit√© des templates")
    print("=" * 40)
    
    try:
        # V√©rifier l'existence des templates
        v11_template = Path("src/lcpi/aep/templates/optimisation_tank_v11.jinja2")
        existing_template = Path("src/lcpi/reporting/templates/base_simple.html")
        
        print(f"Template V11: {'‚úÖ Existe' if v11_template.exists() else '‚ùå Manquant'}")
        print(f"Template existant: {'‚úÖ Existe' if existing_template.exists() else '‚ùå Manquant'}")
        
        if v11_template.exists():
            v11_size = v11_template.stat().st_size
            print(f"   Taille V11: {v11_size} bytes")
        
        if existing_template.exists():
            existing_size = existing_template.stat().st_size
            print(f"   Taille existant: {existing_size} bytes")
        
        # Les deux templates peuvent coexister
        print("‚úÖ Templates compatibles (fonctions diff√©rentes)")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la comparaison des templates: {e}")
        return False

def test_cli_commands_integration():
    """Test l'int√©gration des nouvelles commandes CLI."""
    print("\nüß™ Test d'int√©gration des commandes CLI")
    print("=" * 40)
    
    try:
        from lcpi.aep.optimizer.cli_commands import AEPOptimizationCLI
        
        cli = AEPOptimizationCLI()
        
        # Tester que les m√©thodes sont disponibles
        expected_methods = ['price_optimize', 'report', 'diameters_manage']
        available_methods = [method for method in dir(cli) if not method.startswith('_')]
        
        for method in expected_methods:
            if method in available_methods:
                print(f"‚úÖ M√©thode {method} disponible")
            else:
                print(f"‚ùå M√©thode {method} manquante")
                return False
        
        # Tester les m√©thodes helper
        helper_methods = ['_load_optimization_config', '_validate_network', '_generate_html_report']
        for method in helper_methods:
            if method in available_methods:
                print(f"‚úÖ Helper {method} disponible")
            else:
                print(f"‚ö†Ô∏è  Helper {method} manquant (optionnel)")
        
        print("‚úÖ Toutes les m√©thodes CLI sont disponibles")
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test CLI: {e}")
        return False

def main():
    """Fonction principale."""
    print("üîó Test de Compatibilit√© Format V11 ‚Üî Syst√®me de Rapport LCPI")
    print("=" * 65)
    
    tests = [
        ("Compatibilit√© V11 ‚Üí Log", test_v11_to_log_format_compatibility),
        ("Compatibilit√© Templates", test_v11_template_vs_existing_template),
        ("Int√©gration CLI", test_cli_commands_integration)
    ]
    
    results = []
    for test_name, test_func in tests:
        print(f"\nüî¨ Test: {test_name}")
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"üí• Erreur critique dans {test_name}: {e}")
            results.append((test_name, False))
    
    # R√©sum√© final
    print("\n" + "=" * 65)
    print("üìä R√âSUM√â DE LA COMPATIBILIT√â")
    print("=" * 65)
    
    total_tests = len(results)
    passed_tests = sum(1 for _, result in results if result)
    
    for test_name, result in results:
        status = "‚úÖ COMPATIBLE" if result else "‚ùå INCOMPATIBLE"
        print(f"   {status} - {test_name}")
    
    print(f"\nüéØ Compatibilit√© globale: {passed_tests}/{total_tests} tests r√©ussis")
    
    if passed_tests == total_tests:
        print("üéâ Compatibilit√© compl√®te ! Les formats V11 et Log LCPI sont compatibles.")
        print("üí° Recommandation: Cr√©er un adaptateur V11‚ÜíLog pour int√©gration compl√®te.")
    else:
        print("‚ö†Ô∏è  Probl√®mes de compatibilit√© d√©tect√©s. Adaptations n√©cessaires.")
    
    return passed_tests == total_tests

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
