#!/usr/bin/env python3
"""
D√©monstration des am√©liorations de la Phase 0 de PriceDB.

Ce script d√©montre les nouvelles fonctionnalit√©s impl√©ment√©es :
1. Mod√®le de tarification r√©aliste bas√© sur la loi de puissance
2. Structure de donn√©es harmonis√©e avec dn_mm
3. Gamme √©tendue de diam√®tres de fallback (25mm √† 600mm)
4. Prix calcul√©s dynamiquement au lieu de valeurs en dur
"""

import sys
from pathlib import Path

# Ajouter le r√©pertoire src au path Python
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

def demo_realistic_pricing_model():
    """D√©monstration du mod√®le de tarification r√©aliste"""
    print("üîç D√©monstration du mod√®le de tarification r√©aliste")
    print("=" * 60)
    
    try:
        from lcpi.aep.optimizer.db import _get_realistic_pipe_price, PRICE_MODELS
        
        print("üìä Mod√®les de tarification configur√©s:")
        for material, model in PRICE_MODELS.items():
            print(f"   {material}: Co√ªt = {model['scaling_factor']} √ó D^{model['exponent_b']}")
        
        print("\nüí∞ Exemples de calculs de prix:")
        print("   Format: DN Xmm ‚Üí Prix calcul√© ‚Üí Prix arrondi")
        
        # Test avec diff√©rents diam√®tres et mat√©riaux
        test_cases = [
            (25, "PVC"), (50, "PVC"), (110, "PVC"), (200, "PVC"),
            (63, "PEHD"), (125, "PEHD"), (250, "PEHD"), (315, "PEHD"),
            (100, "Fonte"), (200, "Fonte"), (400, "Fonte"), (600, "Fonte")
        ]
        
        for dn_mm, material in test_cases:
            raw_price = PRICE_MODELS[material]["scaling_factor"] * (dn_mm ** PRICE_MODELS[material]["exponent_b"])
            final_price = _get_realistic_pipe_price(dn_mm, material)
            
            print(f"   DN {dn_mm:3d}mm {material:6s}: {raw_price:8.0f} ‚Üí {final_price:6.0f} FCFA/m")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        return False

def demo_extended_fallback_range():
    """D√©monstration de la gamme √©tendue des diam√®tres de fallback"""
    print("\nüîç D√©monstration de la gamme √©tendue des diam√®tres de fallback")
    print("=" * 60)
    
    try:
        from lcpi.aep.optimizer.db import FALLBACK_DIAMETERS_BASE
        
        print(f"üìè Gamme √©tendue: {len(FALLBACK_DIAMETERS_BASE)} diam√®tres de fallback")
        
        # Grouper par mat√©riau
        materials = {}
        for item in FALLBACK_DIAMETERS_BASE:
            material = item["material"]
            if material not in materials:
                materials[material] = []
            materials[material].append(item["dn_mm"])
        
        print("\nüìã R√©partition par mat√©riau:")
        for material, diameters in materials.items():
            diameters.sort()
            min_dn = min(diameters)
            max_dn = max(diameters)
            print(f"   {material:6s}: {len(diameters):2d} diam√®tres (DN {min_dn:3d}mm - DN {max_dn:3d}mm)")
        
        # Afficher quelques exemples de chevauchement
        print("\nüîÑ Exemples de chevauchement (m√™me diam√®tre, diff√©rents mat√©riaux):")
        overlap_examples = {}
        for item in FALLBACK_DIAMETERS_BASE:
            dn_mm = item["dn_mm"]
            material = item["material"]
            if dn_mm not in overlap_examples:
                overlap_examples[dn_mm] = []
            overlap_examples[dn_mm].append(material)
        
        # Afficher les diam√®tres avec plusieurs mat√©riaux
        for dn_mm, materials_list in sorted(overlap_examples.items()):
            if len(materials_list) > 1:
                print(f"   DN {dn_mm:3d}mm: {', '.join(materials_list)}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        return False

def demo_canonical_structure():
    """D√©monstration de la structure canonique harmonis√©e"""
    print("\nüîç D√©monstration de la structure canonique harmonis√©e")
    print("=" * 60)
    
    try:
        from lcpi.aep.optimizer.db import PriceDB
        
        # Test avec la base principale
        print("üìä Structure depuis la base SQLite principale:")
        db_main = PriceDB()
        main_diameters = db_main.get_candidate_diameters()
        
        if main_diameters:
            example = main_diameters[0]
            print(f"   Exemple de structure:")
            for key, value in example.items():
                print(f"     {key}: {value}")
        
        # Test avec le fallback
        print("\nüìä Structure depuis le fallback:")
        db_fallback = PriceDB("fake_path")
        fallback_diameters = db_fallback.get_candidate_diameters()
        
        if fallback_diameters:
            example = fallback_diameters[0]
            print(f"   Exemple de structure:")
            for key, value in example.items():
                print(f"     {key}: {value}")
        
        # V√©rifier la coh√©rence des structures
        print("\nüîç V√©rification de la coh√©rence:")
        if main_diameters and fallback_diameters:
            main_keys = set(main_diameters[0].keys())
            fallback_keys = set(fallback_diameters[0].keys())
            
            common_keys = main_keys & fallback_keys
            main_only = main_keys - fallback_keys
            fallback_only = fallback_keys - main_keys
            
            print(f"   Cl√©s communes: {len(common_keys)}")
            print(f"   Cl√©s uniquement dans la base principale: {len(main_only)}")
            print(f"   Cl√©s uniquement dans le fallback: {len(fallback_only)}")
            
            if main_only:
                print(f"     Base principale: {', '.join(sorted(main_only))}")
            if fallback_only:
                print(f"     Fallback: {', '.join(sorted(fallback_only))}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        return False

def demo_fallback_scenarios():
    """D√©monstration des diff√©rents sc√©narios de fallback"""
    print("\nüîç D√©monstration des diff√©rents sc√©narios de fallback")
    print("=" * 60)
    
    try:
        from lcpi.aep.optimizer.db import PriceDB
        
        # Sc√©nario 1: Base principale disponible
        print("üìÅ Sc√©nario 1: Base principale disponible")
        db_main = PriceDB()
        info_main = db_main.get_database_info()
        print(f"   Source: {info_main['source_method'] if 'source_method' in info_main else 'Base principale'}")
        print(f"   Diam√®tres: {info_main['diameter_count']}")
        print(f"   Fallback utilis√©: {info_main['fallback_used']}")
        
        # Sc√©nario 2: Base inexistante ‚Üí Fallback automatique
        print("\nüìÅ Sc√©nario 2: Base inexistante ‚Üí Fallback automatique")
        db_fallback = PriceDB("fake_path")
        info_fallback = db_fallback.get_database_info()
        print(f"   Source: {info_fallback['source_method'] if 'source_method' in info_fallback else 'Fallback'}")
        print(f"   Diam√®tres: {info_fallback.get('diameter_count', 'N/A')}")
        print(f"   Fallback utilis√©: {info_fallback['fallback_used']}")
        
        # Comparer les performances
        print("\n‚è±Ô∏è  Comparaison des performances:")
        
        # Test avec la base principale
        import time
        start_time = time.time()
        main_diameters = db_main.get_candidate_diameters()
        main_time = (time.time() - start_time) * 1000
        
        # Test avec le fallback
        start_time = time.time()
        fallback_diameters = db_fallback.get_candidate_diameters()
        fallback_time = (time.time() - start_time) * 1000
        
        print(f"   Base principale: {len(main_diameters)} diam√®tres en {main_time:.2f}ms")
        print(f"   Fallback: {len(fallback_diameters)} diam√®tres en {fallback_time:.2f}ms")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        return False

def demo_price_evolution():
    """D√©monstration de l'√©volution des prix selon le diam√®tre"""
    print("\nüîç D√©monstration de l'√©volution des prix selon le diam√®tre")
    print("=" * 60)
    
    try:
        from lcpi.aep.optimizer.db import _get_realistic_pipe_price
        
        # Analyser l'√©volution des prix pour chaque mat√©riau
        materials = ["PVC", "PEHD", "Fonte"]
        diameter_range = [25, 50, 100, 200, 400, 600]
        
        print("üìà √âvolution des prix (FCFA/m) selon le diam√®tre:")
        print("   DN(mm) |", " | ".join(f"{material:>8}" for material in materials))
        print("   " + "-" * 50)
        
        for dn_mm in diameter_range:
            prices = []
            for material in materials:
                price = _get_realistic_pipe_price(dn_mm, material)
                prices.append(f"{price:>8}")
            print(f"   {dn_mm:>6} |", " | ".join(prices))
        
        # Calculer les ratios de co√ªt
        print("\nüí° Ratios de co√ªt (Prix / Diam√®tre):")
        print("   DN(mm) |", " | ".join(f"{material:>8}" for material in materials))
        print("   " + "-" * 50)
        
        for dn_mm in diameter_range:
            ratios = []
            for material in materials:
                price = _get_realistic_pipe_price(dn_mm, material)
                ratio = price / dn_mm
                ratios.append(f"{ratio:>8.0f}")
            print(f"   {dn_mm:>6} |", " | ".join(ratios))
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        return False

def main():
    """Fonction principale de d√©monstration"""
    print("üöÄ D√©monstration des am√©liorations de la Phase 0 - PriceDB")
    print("=" * 80)
    
    demos = [
        ("Mod√®le de tarification r√©aliste", demo_realistic_pricing_model),
        ("Gamme √©tendue des diam√®tres de fallback", demo_extended_fallback_range),
        ("Structure canonique harmonis√©e", demo_canonical_structure),
        ("Sc√©narios de fallback", demo_fallback_scenarios),
        ("√âvolution des prix selon le diam√®tre", demo_price_evolution),
    ]
    
    results = []
    for demo_name, demo_func in demos:
        print(f"\n{'='*80}")
        try:
            result = demo_func()
            results.append((demo_name, result))
        except Exception as e:
            print(f"‚ùå Erreur inattendue dans {demo_name}: {e}")
            results.append((demo_name, False))
    
    # R√©sum√©
    print(f"\n{'='*80}")
    print("üìä R√âSUM√â DES D√âMONSTRATIONS")
    print("=" * 80)
    
    passed = sum(1 for _, result in results if result)
    total = len(results)
    
    for demo_name, result in results:
        status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHOU√â"
        print(f"{status} {demo_name}")
    
    print(f"\nüéØ R√©sultat global: {passed}/{total} d√©monstrations r√©ussies")
    
    if passed == total:
        print("\nüéâ Toutes les am√©liorations de la Phase 0 fonctionnent parfaitement!")
        print("\nüìã R√©capitulatif des am√©liorations impl√©ment√©es:")
        print("   ‚úÖ Mod√®le de tarification r√©aliste avec loi de puissance")
        print("   ‚úÖ Gamme √©tendue: 25mm √† 600mm (36 diam√®tres)")
        print("   ‚úÖ Structure canonique harmonis√©e (dn_mm partout)")
        print("   ‚úÖ Prix calcul√©s dynamiquement au lieu de valeurs en dur")
        print("   ‚úÖ Fallback robuste avec 3 niveaux de s√©curit√©")
        print("   ‚úÖ Compatibilit√© avec l'ancien code maintenue")
    else:
        print("‚ö†Ô∏è  Certaines d√©monstrations ont √©chou√©. V√©rifiez les d√©tails ci-dessus.")

if __name__ == "__main__":
    main()
