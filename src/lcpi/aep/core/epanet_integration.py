"""
Module d'intégration EPANET avec diagnostics pour LCPI-AEP.

Ce module fournit une interface unifiée pour utiliser EPANET avec
des diagnostics avancés et une gestion d'erreurs robuste.
"""

import os
import tempfile
import time
from typing import Dict, Any, Optional, List
from pathlib import Path

try:
    import epanet
    EPANET_PYTHON_AVAILABLE = True
except ImportError:
    EPANET_PYTHON_AVAILABLE = False

try:
    from epanet_python import epanet as epanet_python
    EPANET_PYTHON_ALT_AVAILABLE = True
except ImportError:
    EPANET_PYTHON_ALT_AVAILABLE = False


class EpanetWithDiagnostics:
    """
    Classe d'intégration EPANET avec diagnostics avancés.
    
    Fournit une interface unifiée pour utiliser EPANET avec des diagnostics
    détaillés et une gestion d'erreurs robuste.
    """
    
    def __init__(self, epanet_path: Optional[str] = None):
        """
        Initialise l'intégration EPANET.
        
        Args:
            epanet_path: Chemin vers la DLL EPANET (optionnel)
        """
        self.epanet_path = epanet_path
        self.epanet_engine = None
        self._initialize_epanet()
    
    def _initialize_epanet(self):
        """Initialise le moteur EPANET."""
        if not EPANET_PYTHON_AVAILABLE and not EPANET_PYTHON_ALT_AVAILABLE:
            raise RuntimeError("Aucune bibliothèque EPANET Python disponible")
        
        try:
            if EPANET_PYTHON_AVAILABLE:
                self.epanet_engine = epanet
            elif EPANET_PYTHON_ALT_AVAILABLE:
                self.epanet_engine = epanet_python
        except Exception as e:
            raise RuntimeError(f"Impossible d'initialiser EPANET: {e}")
    
    def run_with_diagnostics(self, 
                           network_data: Dict[str, Any], 
                           inp_file_path: Optional[str] = None,
                           skip_diagnostics: bool = False) -> Dict[str, Any]:
        """
        Exécute une simulation EPANET avec diagnostics.
        
        Args:
            network_data: Données du réseau (si inp_file_path n'est pas fourni)
            inp_file_path: Chemin vers un fichier .inp existant
            skip_diagnostics: Ignorer les diagnostics pour accélérer
            
        Returns:
            Dictionnaire contenant les résultats et diagnostics
        """
        start_time = time.time()
        
        try:
            # Générer le fichier .inp si nécessaire
            if inp_file_path is None:
                inp_file_path = self._generate_inp_file(network_data)
            
            # Exécuter la simulation EPANET
            simulation_results = self._run_epanet_simulation(inp_file_path)
            
            # Calculer le temps de simulation
            simulation_time = time.time() - start_time
            
            # Ajouter les diagnostics si demandé
            diagnostics = {}
            if not skip_diagnostics:
                diagnostics = self._generate_diagnostics(network_data, simulation_results)
            
            return {
                "success": True,
                "epanet_results": simulation_results,
                "diagnostics": diagnostics,
                "simulation_time": simulation_time,
                "inp_file": inp_file_path
            }
            
        except Exception as e:
            return {
                "success": False,
                "errors": [str(e)],
                "epanet_results": {},
                "diagnostics": {},
                "simulation_time": time.time() - start_time
            }
    
    def _generate_inp_file(self, network_data: Dict[str, Any]) -> str:
        """
        Génère un fichier .inp EPANET à partir des données réseau.
        
        Args:
            network_data: Données du réseau
            
        Returns:
            Chemin du fichier .inp généré
        """
        # Créer un fichier temporaire
        temp_dir = tempfile.gettempdir()
        inp_file = os.path.join(temp_dir, f"lcpi_epanet_{os.getpid()}.inp")
        
        # Générer le contenu du fichier .inp
        inp_content = self._create_inp_content(network_data)
        
        # Écrire le fichier
        with open(inp_file, 'w', encoding='utf-8') as f:
            f.write(inp_content)
        
        return inp_file
    
    def _create_inp_content(self, network_data: Dict[str, Any]) -> str:
        """
        Crée le contenu d'un fichier .inp EPANET.
        
        Args:
            network_data: Données du réseau
            
        Returns:
            Contenu du fichier .inp
        """
        lines = []
        
        # En-tête
        lines.append("[TITLE]")
        lines.append("LCPI-AEP Network Analysis")
        lines.append("Generated by LCPI-AEP")
        lines.append("")
        
        # Nœuds
        lines.append("[JUNCTIONS]")
        lines.append(";ID\tElev\tDemand\tPattern")
        noeuds = network_data.get("noeuds", {})
        for node_id, node in noeuds.items():
            if node.get("role") == "consommation":
                elevation = node.get("cote_m", 0)
                demand = node.get("demande_m3_s", 0) * 1000  # Convertir en L/s
                lines.append(f"{node_id}\t{elevation:.2f}\t{demand:.3f}\t")
        lines.append("")
        
        # Réservoirs
        lines.append("[RESERVOIRS]")
        lines.append(";ID\tHead\tPattern")
        for node_id, node in noeuds.items():
            if node.get("role") == "reservoir":
                head = node.get("cote_m", 0)
                lines.append(f"{node_id}\t{head:.2f}\t")
        lines.append("")
        
        # Conduites
        lines.append("[PIPES]")
        lines.append(";ID\tNode1\tNode2\tLength\tDiameter\tRoughness\tMinorLoss\tStatus")
        conduites = network_data.get("conduites", {})
        for conduit_id, conduit in conduites.items():
            node1 = conduit.get("noeud_amont", "")
            node2 = conduit.get("noeud_aval", "")
            length = conduit.get("longueur_m", 0)
            diameter = conduit.get("diametre_m", 0) * 1000  # Convertir en mm
            roughness = conduit.get("rugosite", 100)
            lines.append(f"{conduit_id}\t{node1}\t{node2}\t{length:.1f}\t{diameter:.0f}\t{roughness:.0f}\t0\tOpen")
        lines.append("")
        
        # Options
        lines.append("[OPTIONS]")
        lines.append("UNITS\tLPS")
        lines.append("HEADLOSS\tH-W")
        lines.append("QUALITY\tNone")
        lines.append("")
        
        # Période de simulation
        lines.append("[TIMES]")
        lines.append("Duration\t24:00")
        lines.append("Hydraulic\t01:00")
        lines.append("")
        
        # Rapport
        lines.append("[REPORT]")
        lines.append("Status\tYES")
        lines.append("Summary\tYES")
        lines.append("")
        
        return "\n".join(lines)
    
    def _run_epanet_simulation(self, inp_file_path: str) -> Dict[str, Any]:
        """
        Exécute une simulation EPANET.
        
        Args:
            inp_file_path: Chemin vers le fichier .inp
            
        Returns:
            Résultats de la simulation
        """
        try:
            # Ouvrir le fichier .inp
            self.epanet_engine.ENopen(inp_file_path, inp_file_path.replace('.inp', '.rpt'), "")
            
            # Initialiser la simulation
            self.epanet_engine.ENopenH()
            self.epanet_engine.ENinitH(0)
            
            # Variables pour stocker les résultats
            pressures = {}
            flows = {}
            velocities = {}
            
            # Exécuter la simulation pas par pas
            t = 0
            while True:
                tstep = self.epanet_engine.ENrunH()
                if tstep <= 0:
                    break
                
                # Récupérer les résultats pour ce pas de temps
                self._extract_results_at_timestep(pressures, flows, velocities)
                
                t += tstep
                self.epanet_engine.ENnextH()
            
            # Fermer la simulation
            self.epanet_engine.ENcloseH()
            self.epanet_engine.ENclose()
            
            return {
                "pressions": pressures,
                "flows": flows,
                "velocities": velocities
            }
            
        except Exception as e:
            # Fermer proprement en cas d'erreur
            try:
                self.epanet_engine.ENcloseH()
                self.epanet_engine.ENclose()
            except:
                pass
            raise e
    
    def _extract_results_at_timestep(self, pressures: Dict[str, float], 
                                   flows: Dict[str, float], 
                                   velocities: Dict[str, float]):
        """
        Extrait les résultats pour le pas de temps actuel.
        
        Args:
            pressures: Dictionnaire des pressions à remplir
            flows: Dictionnaire des débits à remplir
            velocities: Dictionnaire des vitesses à remplir
        """
        try:
            # Récupérer les pressions des nœuds
            node_count = self.epanet_engine.ENgetcount(self.epanet_engine.EN_NODECOUNT)
            for i in range(1, node_count + 1):
                node_id = self.epanet_engine.ENgetnodeid(i)
                pressure = self.epanet_engine.ENgetnodevalue(i, self.epanet_engine.EN_PRESSURE)
                pressures[node_id] = pressure
            
            # Récupérer les débits et vitesses des conduites
            link_count = self.epanet_engine.ENgetcount(self.epanet_engine.EN_LINKCOUNT)
            for i in range(1, link_count + 1):
                link_id = self.epanet_engine.ENgetlinkid(i)
                flow = self.epanet_engine.ENgetlinkvalue(i, self.epanet_engine.EN_FLOW)
                flows[link_id] = flow
                
                # Calculer la vitesse (approximatif)
                link_type = self.epanet_engine.ENgetlinktype(i)
                if link_type == self.epanet_engine.EN_PIPE:
                    diameter = self.epanet_engine.ENgetlinkvalue(i, self.epanet_engine.EN_DIAMETER)
                    if diameter > 0:
                        area = 3.14159 * (diameter / 1000) ** 2 / 4  # m²
                        velocity = abs(flow / 1000) / area  # m/s
                        velocities[link_id] = velocity
                        
        except Exception as e:
            # En cas d'erreur, on continue avec les données disponibles
            pass
    
    def _generate_diagnostics(self, network_data: Dict[str, Any], 
                            simulation_results: Dict[str, Any]) -> Dict[str, Any]:
        """
        Génère des diagnostics sur le réseau et les résultats.
        
        Args:
            network_data: Données du réseau
            simulation_results: Résultats de la simulation
            
        Returns:
            Dictionnaire des diagnostics
        """
        diagnostics = {
            "boucles_detectees": 0,
            "nœuds_isoles": [],
            "conduites_critiques": [],
            "pression_min": float('inf'),
            "pression_max": float('-inf'),
            "vitesse_min": float('inf'),
            "vitesse_max": float('-inf')
        }
        
        # Analyser les pressions
        pressures = simulation_results.get("pressions", {})
        if pressures:
            diagnostics["pression_min"] = min(pressures.values())
            diagnostics["pression_max"] = max(pressures.values())
        
        # Analyser les vitesses
        velocities = simulation_results.get("velocities", {})
        if velocities:
            diagnostics["vitesse_min"] = min(velocities.values())
            diagnostics["vitesse_max"] = max(velocities.values())
        
        # Détecter les nœuds isolés
        noeuds = network_data.get("noeuds", {})
        conduites = network_data.get("conduites", {})
        
        connected_nodes = set()
        for conduit in conduites.values():
            connected_nodes.add(conduit.get("noeud_amont"))
            connected_nodes.add(conduit.get("noeud_aval"))
        
        for node_id in noeuds:
            if node_id not in connected_nodes:
                diagnostics["nœuds_isoles"].append(node_id)
        
        # Détecter les boucles (approximation simple)
        # Une boucle est détectée si un nœud a plus de 2 connexions
        node_connections = {}
        for conduit in conduites.values():
            node1 = conduit.get("noeud_amont")
            node2 = conduit.get("noeud_aval")
            node_connections[node1] = node_connections.get(node1, 0) + 1
            node_connections[node2] = node_connections.get(node2, 0) + 1
        
        for node_id, connections in node_connections.items():
            if connections > 2:
                diagnostics["boucles_detectees"] += 1
        
        return diagnostics 